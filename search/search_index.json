{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The goal of this repository is to document the creation of a simple Internal Developer Platform for me. I will call this platform as Platformoon.</p> <p>This repository is a collection of documents that explain the different parts of the platform, decisions, and how I build it.</p>"},{"location":"#why","title":"Why?","text":"<p>I am a Software Engineer at MercadoLibre, I am working on the Cloud &amp; Platform TEAM creating developer toolings on top of Fury (an internal platform here), it is a great experience for me. </p> <p>With this initiative I want to build a simple an IDP skeleton to learn more about CNCF toolings and to share it with you!</p> <p>Disclaimer</p> <p>I know that it is not a real platform, but I want to learn more about this topic and I want to learn more about CNCF toolings and to share it with you.</p>"},{"location":"#platform-engineering-on-kubernetes-book","title":"Platform Engineering on Kubernetes Book","text":"<p>I am creating this repository having as a reading/reference the book Platform Engineering on Kubernetes by Mauricio Salatino. </p> <p>I contributed with some part of the code sample of the book in this repository and feel free to contribute too.</p>"},{"location":"archictecture/","title":"Introduction","text":"<p>I want that the architecture should be simple and easy to understand. I want to use the power of Kubernetes to create a simple platform that can be used by developers to deploy their applications.</p> <p>I will use a monolithic architecture to create the platform. Is simple to start and to understand too.</p>"},{"location":"archictecture/#architecture","title":"Architecture","text":"<p>The architecture will be composed of the following components:</p> <ul> <li>Kubernetes Cluster</li> <li>Platformoon API (Java/Quarkus)</li> <li>Platformoon Frontend (NextJS)</li> <li>Platformoon CLI (GoLang)</li> <li>Platformoon Documentation (mkdocs)</li> <li>Keycloak</li> </ul> <p>The main goal here is to learn and to get out from comfort zone. I hope that you can learn something too.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#allow-the-user-to-create-an-application-through-the-cli","title":"Allow the user to create an application through the CLI","text":"<p>The command should be something like this:</p> <pre><code>    platformoon create application --name=app --kind=backend\n</code></pre> <p>The result of this operation should be:</p> <ul> <li>The repository created on Github</li> <li>The application stored to be retrieved later</li> </ul>"},{"location":"features/#what-is-necessary-to-do-it","title":"What is necessary to do it?","text":"<ul> <li>Create an organization on Github</li> <li>Get the token from Github</li> <li>Create a repository on Github for the API</li> <li>Create a repository for the CLI</li> </ul> <p>Note</p> <p>For now, I will not install Keycloak and the communication between the CLI and the API will be unsafe.</p>"},{"location":"strategies/","title":"What we need first?","text":"<p>Before all, I think that we need to define what initial applications types we need to support.</p> <p>We will support only backend applications written in Go only.</p> <p>The application will be those fields:</p> <ul> <li>Name</li> <li>Description</li> <li>Repository URL (Generated by the platform)</li> <li>Technology</li> <li>Kind (backend)</li> </ul> <p>It is all, we do not need to support initially more than one backend application type. We will get the feeling configuring pipelines, deployments for one application type and then we will be able to extend the platform to support more application types.</p>"},{"location":"strategies/pipelines/","title":"Pipelines","text":"<p>To run our Platform pipelines I want to use GithubActions + Dagger. Dagger is a tool that allows us to run our pipelines locally. Dagger was born with this main goal: </p> <p>\u201cto enable developers to build pipelines using their favorite programming language that they can run everywhere\u201d.</p> <p>I like this because we can use the power of the GoLang combined with the power of Dagger to create our pipelines.</p>"},{"location":"strategies/pipelines/#what-we-need-first","title":"What we need first?","text":"<p>I think that is a good idea to create a repository to store all our pipelines. This repository will be called <code>platformoon-pipelines</code>. I will do it manually with Github.</p>"},{"location":"tutorials/","title":"Creating a Kubernetes cluster in Docker cluster with Ingress Controller","text":"<p>More details about the following steps can be found here. <pre><code>cat &lt;&lt;EOF | kind create cluster --name dev --config=-\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnodes:\n- role: control-plane\n  kubeadmConfigPatches:\n  - |\n    kind: InitConfiguration\n    nodeRegistration:\n      kubeletExtraArgs:\n        node-labels: \"ingress-ready=true\"\n  extraPortMappings:\n  - containerPort: 80\n    hostPort: 80\n    protocol: TCP\n  - containerPort: 443\n    hostPort: 443\n    protocol: TCP\n- role: worker\n- role: worker\n- role: worker\nEOF\n</code></pre></p> <p>After you need to set up the context.</p> <pre><code>kubectl cluster-info --context kind-dev\n</code></pre>"},{"location":"tutorials/#installing-the-nginx-ingress-controller","title":"Installing the NGINX Ingress Controller","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml\n</code></pre>"},{"location":"tutorials/calling-rest-api-using-go-lang/","title":"Calling REST API Using GoLang: Hands-On","text":""},{"location":"tutorials/calling-rest-api-using-go-lang/#creating-a-http-client-to-perform-requests","title":"Creating a HTTP Client to perform requests","text":"<p>Let's create a simple file that will be used to make HTTP request:</p> internal/httpclient/httpclient.go<pre><code>package httpclient\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"net/http\"\n)\n\nfunc Post(url string, body interface{}) (*http.Response, error) {\n\n    marshal, err := json.Marshal(body)\n    if err != nil {\n        panic(any(err))\n    }\n\n    byteArr := []byte(marshal)\n\n    return http.Post(url, \"application/json\", bytes.NewBuffer(byteArr))\n\n}\n</code></pre>"},{"location":"tutorials/calling-rest-api-using-go-lang/#creating-the-application-responsible-for-application","title":"Creating the application responsible for Application","text":"<p>This module contain all things about application.</p> <p>Let's get the implementation:</p> internal/application/application.go<pre><code>package application\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"github.com/mcruzdev/platformoon-cli/internal/httpclient\"\n)\n\ntype ApplicationRequest struct {\n    Name       string `json:\"name\"`\n    Type       string `json:\"type\"`\n    Technology string `json:\"technology\"`\n}\n\nfunc NewApplicationRequest(name, appType, technology string) *ApplicationRequest {\n    return &amp;ApplicationRequest{\n        Name:       name,\n        Technology: technology,\n        Type:       appType,\n    }\n}\n\nfunc CreateNewApplication(name, appType, technology string) {\n    ar := NewApplicationRequest(name, appType, technology)\n    r, err := httpclient.Post(\"http://localhost:8080/applications\", ar)\n\n    if err != nil {\n        panic(any(err))\n    }\n\n    if r.StatusCode == http.StatusCreated {\n        log.Printf(\"Application created: %s\", r.Header[\"Location\"])\n    }\n}\n</code></pre>"},{"location":"tutorials/calling-rest-api-using-go-lang/#change-application-create-command","title":"Change application create command","text":"<p>Finally, let's change the handle for <code>platformoon application create</code> command:</p> cmd/platformoon/platformoon.go<pre><code>func NewApplicationCreateCmd() *cobra.Command {\n    var cmd = &amp;cobra.Command{\n        Use:   \"create\",\n        Short: \"This command is used to create a new application\",\n        Run: func(cmd *cobra.Command, args []string) {\n            log.Println(\"platformoon application create works\")\n            application.CreateNewApplication(\"application\", \"API\", \"JAVA\") // (1)\n        },\n    }\n\n    return cmd\n}\n</code></pre> <ol> <li>This values are hard-coded, we will change it later.</li> </ol>"},{"location":"tutorials/calling-rest-api-using-go-lang/#calling-the-rest-api","title":"Calling the REST API","text":"<p>Now, that all things are okay, let's execute our CLI:</p> <p>Note</p> <p>Check if the REST API is running.</p> <pre><code>go run cmd/platformoon/platformoon.go application create\n</code></pre> <p>The output should looks something like it:</p> <pre><code>2023/10/27 22:44:54 platformoon application create works\n2023/10/27 22:44:54 Application created: [http://localhost:8080/applications/06ce9936-4a74-4328-b2f7-f4e40e310706]\n</code></pre>"},{"location":"tutorials/calling-rest-api-using-go-lang/#thank-you","title":"Thank you!","text":"<p>Done! The next step is to add parameters to the CLI, follow this tutorial to do it.</p>"},{"location":"tutorials/continuous-delivery/","title":"Configuring Github Webhooks","text":"<p>In this tutorial we will configure a Github Webhook and listen all events from Github using Quarkus and <code>ngrok</code> toolings.</p>"},{"location":"tutorials/continuous-delivery/#installing-and-configuring-ngrok","title":"Installing and configuring ngrok","text":"<p>If you are not familiar with <code>ngrok</code>, see more details here.</p>"},{"location":"tutorials/continuous-delivery/#configuring-ngrok","title":"Configuring ngrok","text":"<p>Before continuing, you need to install <code>ngrok</code>, to see how to do it, follow this Getting Started tutorial.</p>"},{"location":"tutorials/continuous-delivery/#creating-a-rest-resource","title":"Creating a REST resource","text":"<p>Let's go to the our application. I created a REST resource just to log the request body from Github event.</p> <pre><code>package com.github.platformoon.presentation.resources;\n\nimport jakarta.ws.rs.Consumes;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Path(\"/gh/webhooks\")\n@Consumes(value = MediaType.APPLICATION_JSON)\n@Produces(value = MediaType.APPLICATION_JSON)\npublic class GithubWebhookResource {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(GithubWebhookResource.class);\n\n    public Response listen(String command) {\n        LOGGER.info(command);\n        return Response.ok().build();\n    }\n}\n</code></pre>"},{"location":"tutorials/continuous-delivery/#running-quarkus-application","title":"Running Quarkus application","text":"<p>Is very simple to run a Quarkus application, I am using <code>quarkus</code> CLI to do it.</p> <p>Execute the following command at the application root directory:</p> <pre><code>quarkus dev\n</code></pre> <p>The output should looks like it:</p> <pre><code>2023-10-10 09:28:37,871 INFO  [io.qua.kub.cli.dep.DevServicesKubernetesProcessor] (build-39) Dev Services for Kubernetes started. Other Quarkus applications in dev mode will find the cluster automatically.\n__  ____  __  _____   ___  __ ____  ______ \n --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/ \n -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\\ \\   \n--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/   \n2023-10-10 09:28:39,746 INFO  [io.quarkus] (Quarkus Main Thread) apps 1.0-SNAPSH2023-10-10 09:28:39,749 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.\n2023-10-10 09:28:39,750 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [agroal, cdi, hibernate-orm, jdbc-mysql, kubernetes-client, narayana-jta, rest-client, rest-client-jackson, resteasy, smallrye-context-propagation, vertx]\n</code></pre>"},{"location":"tutorials/continuous-delivery/#running-ngrok","title":"Running ngrok","text":"<p>After running the Quarkus application, will be able to execute the <code>ngrok</code>, to do it execute:</p> <pre><code>ngrok http 8080\n</code></pre> <p>The <code>http</code> say to the <code>ngrok</code> to use HTTP protocol and the 8080 indicates to proxy the request to the port 8080 (the default port used by Quarkus). The output should looks like it:</p> <pre><code>Introducing Always-On Global Server Load Balancer: https://ngrok.com/r/gslb                                                                           \n\nSession Status                online                                                                                                                  \nAccount                       email@gmail.com (Plan: Free)                                                                                  \nVersion                       3.3.5                                                                                                                   \nRegion                        South America (sa)                                                                                                      \nLatency                       13ms                                                                                                                    \nWeb Interface                 http://127.0.0.1:4040                                                                                                   \nForwarding                    https://1234-1234-7f0-90c0-6628-abcd-65c-1234-5fc6.ngrok-free.app -&gt; http://localhost:8080                              \n\nConnections                   ttl     opn     rt1     rt5     p50     p90                                                                             \n                              0       0       0.00    0.00    0.00    0.00       \n</code></pre>"},{"location":"tutorials/continuous-delivery/#configuring-the-org-webhook","title":"Configuring the org Webhook","text":"<p>Now, that we have the URL necessary to send the Webhook to our platform, let's configure it on Github.</p> <ol> <li> <p>Go to Github &gt; Settings &gt; Organizations.</p> </li> <li> <p>Select the Organization that you want, and click in Settings.</p> </li> <li> <p>Go to Webhooks.</p> </li> <li> <p>Click on <code>Add webhook</code> button.</p> </li> <li> <p>Add the Payload URL with the <code>ngrok</code> URL (in my case was necessary to add the path <code>/gh/webhooks</code> for listen it).</p> </li> <li> <p>Select <code>Let me select individual events</code>, we need just to listen tag creation and  </p> </li> <li>Click on <code>Add webhook</code> button to save.</li> </ol> <p>Done, now we can listen for all Github events and manage it.</p>"},{"location":"tutorials/creating-a-golang-cli-with-cobra/","title":"Creating a GoLang with Cobra: Hands-On","text":"<p>In this tutorial, we will create a command-line application in GoLang.</p>"},{"location":"tutorials/creating-a-golang-cli-with-cobra/#prerequisites","title":"Prerequisites","text":"<ul> <li>GoLang version 1.20 or higher</li> </ul>"},{"location":"tutorials/creating-a-golang-cli-with-cobra/#creating-the-golang-application","title":"Creating the GoLang application","text":"<p>Starting a GoLang application is quite simple; you just need to create a folder and run the command <code>go mod init [module-path]</code>.</p> <p>Let's create:</p> <pre><code>mkdir platformoon-cli &amp;&amp; cd platformoon-cli\ngo mod init github.com/mcruzdev/platformoon-cli\n</code></pre> <p>If you type <code>tree .</code> in terminal, the output should looks like:</p> <pre><code>.\n\u2514\u2500\u2500 go.mod\n</code></pre> <p>Let's see the <code>go.mod</code> content:</p> <pre><code>module github.com/mcruzdev/platformoon-cli\n\ngo 1.20\n</code></pre>"},{"location":"tutorials/creating-a-golang-cli-with-cobra/#installing-cobra-dependency","title":"Installing Cobra dependency","text":"<p>Cobra overview:</p> <p>Cobra is a library providing a simple interface to create powerful modern CLI interfaces similar to git &amp; go tools.</p> <p>Getting the dependency with <code>go</code>:</p> <pre><code>go get -u github.com/spf13/cobra@latest\n</code></pre>"},{"location":"tutorials/creating-a-golang-cli-with-cobra/#creating-the-root-command-platformoon","title":"Creating the root command (platformoon)","text":"<p>Let's see the initial code:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/spf13/cobra\"\n)\n\nfunc main() { // (1)\n    rootCmd := NewPlatformoonRoot()\n    if err := rootCmd.Execute(); err != nil {\n        fmt.Fprintln(os.Stderr, err)\n        os.Exit(1)\n    }\n}\n\nfunc NewPlatformoonRoot() *cobra.Command { // (2)\n    var root = &amp;cobra.Command{\n        Use:   \"platformoon\",\n        Short: \"Platformoon CLI facilitates programmers lifes\",\n        Run: func(cmd *cobra.Command, args []string) {\n            log.Println(\"platformoon works\")\n        },\n    }\n\n    return root\n}\n</code></pre> <ol> <li>main GoLang function</li> <li>Factory function to create the root <code>*cobra.Command</code></li> </ol>"},{"location":"tutorials/creating-a-golang-cli-with-cobra/#testing-the-cli","title":"Testing the CLI","text":"<p>Run the application:</p> <pre><code>go run cmd/platformoon/platformoon.go\n</code></pre> <p>The output should looks something like this:</p> <pre><code>2023/10/27 20:47:56 platformoon works\n</code></pre> <p>Great, let's create the complete command <code>platformoon application create --name [application-name]</code>.</p>"},{"location":"tutorials/creating-a-golang-cli-with-cobra/#adding-subcommands-to-the-platformoon-command","title":"Adding subcommands to the platformoon command","text":"<pre><code>func NewPlatformoonRoot() *cobra.Command {\n    var root = &amp;cobra.Command{\n        Use:   \"platformoon\",\n        Short: \"Platformoon CLI facilitates programmers lifes\",\n        Run: func(cmd *cobra.Command, args []string) {\n            log.Println(\"platformoon works\")\n        },\n    }\n\n    root.AddCommand(NewApplicationCmd()) // (1)\n\n    return root\n}\n\nfunc NewApplicationCmd() *cobra.Command { // (2)\n    var cmd = &amp;cobra.Command{\n        Use:   \"application\",\n        Short: \"This command consists of multiple subcommands to interact with applications\",\n        Run: func(cmd *cobra.Command, args []string) {\n            log.Println(\"platformoon application works\")\n        },\n    }\n\n    cmd.AddCommand(NewApplicationCreateCmd()) // (3)\n    return cmd\n}\n\nfunc NewApplicationCreateCmd() *cobra.Command { // (4)\n    var cmd = &amp;cobra.Command{\n        Use:   \"create\",\n        Short: \"This command is used to create a new application\",\n        Run: func(cmd *cobra.Command, args []string) {\n            log.Println(\"platformoon application create works\")\n        },\n    }\n\n    return cmd\n}\n</code></pre> <ol> <li>Add <code>[application]</code> command as subcommand</li> <li>Create <code>application</code> command</li> <li>Add <code>create</code> command as <code>application</code> subcommand</li> <li>Create <code>create</code> command </li> </ol> <p>Note</p> <p>The Cobra documentation recommends organizing the subcommands in a slightly different way, for didactic purposes, and to fit within this tutorial, we will place them in the same file. See more details here.</p>"},{"location":"tutorials/creating-a-golang-cli-with-cobra/#building-the-application","title":"Building the application","text":"<p>To test how the end user experience will be, let's build our CLI.</p> <pre><code>go build -o platformoon cmd/platformoon/platformoon.go \n</code></pre>"},{"location":"tutorials/creating-a-golang-cli-with-cobra/#testing-the-application","title":"Testing the application","text":"<p>Add permission to execute:</p> <pre><code>chmod +x platformoon\n</code></pre> <p>Execute the following commands and see the result:</p> <pre><code>./platformoon application\n</code></pre> <pre><code>./platformoon application create\n</code></pre>"},{"location":"tutorials/creating-a-golang-cli-with-cobra/#adding-the-logic-to-send-http-request-to-rest-api","title":"Adding the logic to send HTTP request to REST API","text":"<p>So far, the API doesn't exist yet, so let's create it now. Access this tutorial to create a Quarkus application that will serve as our REST API.</p> <p>Note</p> <p>Don't worry, we'll return to working with our CLI as soon as we create our REST API.</p> <p>Commit and push your changes to access later.</p>"},{"location":"tutorials/creating-a-quarkus-rest-api/","title":"Creating a Quarkus REST API: Hands-On","text":"<p>In this tutorial, we will create a Quakus REST API with Java.</p>"},{"location":"tutorials/creating-a-quarkus-rest-api/#prerequisites","title":"Prerequisites","text":"<ul> <li>Quarkus CLI</li> </ul> <p>I am using the version 3.1.0.Final.</p>"},{"location":"tutorials/creating-a-quarkus-rest-api/#creating-the-quarkus-application","title":"Creating the Quarkus application","text":"<p>Let's create our API with quarkus CLI:</p> <pre><code>quarkus create app com.github.platformoon:platformoon-api\n</code></pre> <ul> <li> <p><code>com.github.platformoon</code> is the groupId.</p> </li> <li> <p><code>platformoon-api</code> is the artifactId.</p> </li> </ul>"},{"location":"tutorials/creating-a-quarkus-rest-api/#running-our-api","title":"Running our API","text":"<p>Go to the <code>platformoon-api</code> directory.</p> <p>And execute:</p> <pre><code>quarkus dev\n</code></pre> <p>The output should looks something like this:</p> <pre><code> --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/ \n -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\\ \\   \n--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/   \n2023-10-27 21:28:54,604 INFO  [io.quarkus] (Quarkus Main Thread) platformoon-api 1.0.0-SNAPSHOT on JVM (powered by Quarkus 3.5.0) started in 1.742s. Listening on: http://localhost:8080\n\n2023-10-27 21:28:54,608 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.\n2023-10-27 21:28:54,608 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, resteasy-reactive, smallrye-context-propagation, vertx]\n</code></pre> <p>If you access your browser at: http://localhost:8008/hello, you will get a response from the API.</p>"},{"location":"tutorials/creating-a-quarkus-rest-api/#installing-resteasy-reactive-jackson","title":"Installing RESTEasy Reactive Jackson","text":"<p>Let's install Jackson to get support for JSON Serialisation:</p> <pre><code>quarkus ext add io.quarkus:quarkus-resteasy-reactive-jackson\n</code></pre>"},{"location":"tutorials/creating-a-quarkus-rest-api/#creating-the-resource","title":"Creating the Resource","text":"com.github.platformoon.presentation.resource.ApplicationResource<pre><code>package com.github.platformoon.presentation.resource;\n\nimport java.net.URI;\nimport java.util.UUID;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.github.platformoon.presentation.resource.request.CreateApplicationRequest;\n\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.core.Response;\n\n@Path(\"/applications\")\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\npublic class ApplicationResource {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ApplicationResource.class);\n\n    @POST\n    public Response createApplicationHandler(final CreateApplicationRequest request) {\n        LOGGER.info(\"createApplicationHandler: {}\", request);\n\n        return Response\n            .created(\n                URI.create(\"/applications/\" + UUID.randomUUID().toString()))\n            .build();\n    }\n}\n</code></pre>"},{"location":"tutorials/creating-a-quarkus-rest-api/#creating-the-dto","title":"Creating the DTO","text":"com.github.platformoon.presentation.resource.request.CreateApplicationRequest<pre><code>package com.github.platformoon.presentation.resource.request;\n\npublic record CreateApplicationRequest(String name, String technology) {}\n</code></pre>"},{"location":"tutorials/creating-a-quarkus-rest-api/#testing-the-resource","title":"Testing the resource","text":"<p>Execute the application with <code>quarkus dev</code> and make a request to the new endpoint:</p> <pre><code>curl -v --request POST \\\n  --url http://localhost:8080/applications \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n    \"name\": \"application\",\n    \"technology\": \"JAVA\",\n    \"type\": \"API\"\n}'\n</code></pre> <p>We can observe the response header 'Location' containing the resource URI. If we check the Quarkus log, we may find something like this:</p> <pre><code>2023-10-27 22:09:29,646 INFO  [com.git.pla.pre.res.ApplicationResource] (executor-thread-1) createApplicationHandler: CreateApplicationRequest[name=application, technology=JAVA, type=API]\n</code></pre>"},{"location":"tutorials/creating-a-quarkus-rest-api/#done","title":"Done","text":"<p>Let's return to the Platformoon CLI and implement an HTTP call to this new endpoint. Go to the Calling REST API using GoLang tutorial.</p>"},{"location":"tutorials/pipelines/","title":"Getting Started","text":"<p>To get started with pipelines and Tekton you need a Kubernetes cluster.</p> <p>We are use KinD installed on this tutorial Installing KinD</p>"},{"location":"tutorials/pipelines/#installing-tekton","title":"Installing Tekton","text":""},{"location":"tutorials/pipelines/#why-tekton","title":"Why Tekton?","text":"<p>I wanted to learn more about Tekton and I decided to use it on this project. Tekton is a powerful and flexible open-source framework for creating CI/CD systems, allowing developers to build, test, and deploy across cloud providers and on-premise systems. It is built on Kubernetes, providing the benefits of an open-source, cloud-native experience from pipeline creation to execution.</p> <p>For more details see the official documentation.</p>"},{"location":"tutorials/pipelines/#intalling-tekton-pipelines","title":"Intalling Tekton Pipelines","text":"<pre><code>kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml\n</code></pre>"},{"location":"tutorials/pipelines/#installing-tekton-trigger","title":"Installing Tekton Trigger","text":"<pre><code>kubectl apply --filename \\\nhttps://storage.googleapis.com/tekton-releases/triggers/latest/release.yaml\nkubectl apply --filename \\\nhttps://storage.googleapis.com/tekton-releases/triggers/latest/interceptors.yaml\n</code></pre>"},{"location":"tutorials/pipelines/#installing-tekton-dashboard","title":"Installing Tekton Dashboard","text":"<pre><code>kubectl apply -f https://github.com/tektoncd/dashboard/releases/download/v0.33.0/release.yaml\n</code></pre> <p>You can access the dashboard using the following command:</p> <pre><code>kubectl port-forward svc/tekton-dashboard  -n tekton-pipelines 9097:9097\n</code></pre>"},{"location":"tutorials/pipelines/#installing-git-clone-and-buildpacks-tasks-from-tekton-hub","title":"Installing git-clone and buildpacks tasks from Tekton Hub","text":"<p>In this step we will install two tekton tasks from Tekton Hub, the git-clone and the buildpacks.</p> <p><code>git-clone</code> is a task that clones a git repository into a <code>Workspace</code> volume.</p> <p><code>buildpacks</code> is a task that builds an application using Cloud Native Buildpacks.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/tektoncd/catalog/main/task/git-clone/0.9/git-clone.yaml\nkubectl apply -f https://raw.githubusercontent.com/tektoncd/catalog/master/task/buildpacks/0.6/buildpacks.yaml\n</code></pre>"},{"location":"tutorials/pipelines/#installing-tekton-objects","title":"Installing Tekton Objects","text":"<pre><code>kubectl apply -f tekton/ci\n</code></pre>"},{"location":"tutorials/pipelines/#installing-ingress-controller-for-tekton","title":"Installing Ingress Controller for Tekton","text":"<pre><code>kubectl apply -f tekton/ingress.yaml\n</code></pre> <p>Now we have a webhook configured and we can run the pipeline using the following command:</p> <pre><code>curl --request POST \\\n  --url http://localhost/tkn/webhook \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n    \"url\": \"https://github.com/platformoon/destroyer-server.git\",\n    \"revision\": \"main\",\n    \"applicationName\": \"destroyer-server\",\n    \"action\": \"build\"\n}'\n</code></pre> <p>You can see the pipeline running at http://tekton.localhost.</p>"},{"location":"tutorials/using-parameters-on-cobra-cli/","title":"Using Parameters on Cobra CLI: Hands-On","text":""},{"location":"tutorials/using-parameters-on-cobra-cli/#adding-parameters","title":"Adding parameters","text":"<p>The Cobra documentation says that:</p> <p>There are two different approaches to assign a flag. Persistent and Local Flags.</p> <p>Persistent</p> <p>A flag can be 'persistent', meaning that this flag will be available to the command it's assigned to as well as every command under that command. For global flags, assign a flag as a persistent flag on the root.</p> <p>Local Flags</p> <p>A flag can also be assigned locally, which will only apply to that specific command.</p>"},{"location":"tutorials/using-parameters-on-cobra-cli/#required-flags","title":"Required flags","text":"<p>We will use local flags, and we need to ensure that all flags are provided.</p> <p>Flags are optional by default. If instead you wish your command to report an error when a flag has not been set, mark it as required.</p> <p>In our case, we need to be sure that <code>--name</code>, <code>--type</code> and <code>--technology</code> are provided together, then it makes sense for us.</p>"},{"location":"tutorials/using-parameters-on-cobra-cli/#changing-the-code","title":"Changing the code","text":"<p>Let's change the <code>NewApplicationCreateCmd()</code> function.</p> cmd/platformoon/platformoon.go<pre><code>func NewApplicationCreateCmd() *cobra.Command {\n    var cmd = &amp;cobra.Command{\n        Use:   \"create [OPTIONS]\",\n        Short: \"This command is used to create a new application\",\n        Run: func(cmd *cobra.Command, args []string) {\n            log.Println(\"platformoon application create works\")\n            application.CreateNewApplication(\"application\", \"API\", \"JAVA\")\n        },\n    }\n\n    cmd.Flags().StringVarP(&amp;applicationName, \"name\", \"n\", \"\", \"Application name\")\n    cmd.Flags().StringVarP(&amp;technology, \"technology\", \"t\", \"\", \"Technology of the application, e.g., (java, go)\")\n    cmd.Flags().StringVarP(&amp;appType, \"kind\", \"k\", \"\", \"Kind of the application, e.g., web, library\")\n\n    return cmd\n}\n</code></pre> <p><code>StringVarP</code> method:</p> <ol> <li>\"name\" means the flag name</li> <li>\"n\" means the short name</li> <li>\"\" means default value is empty</li> <li>\"Application name\" means the help message for this flag </li> </ol> <p>We can see that we are using three variables: <code>applicationName</code>, <code>technology</code> and <code>appType</code>. Let's declare at the top of the file.</p> cmd/platformoon/platformoon.go<pre><code>var (\n    applicationName string\n    technology      string\n    appType         string\n)\n</code></pre> <p>Now, all options are required, let's use them!</p> cmd/platformoon/platformoon.go<pre><code>Run: func(cmd *cobra.Command, args []string) {\n    log.Println(\"platformoon application create works\")\n    application.CreateNewApplication(applicationName, appType, technology) // (1)\n},\n</code></pre> <ol> <li>Replace hard-coded values with the variables</li> </ol>"},{"location":"tutorials/using-parameters-on-cobra-cli/#validation","title":"Validation","text":"<p>In the real world, when a flag is not valid, we don't even make the REST API call, needlessly expending time and computational resources. It would be much better to validate on the client side first, as it's a straightforward task like data validation.</p> <p>Let's add validation to the method that creates the struct <code>ApplicationRequest</code> for the request.</p> internal/application/application.go<pre><code>func NewApplicationRequest(name, appType, technology string) *ApplicationRequest {\n\n    technologies := []string{\"JAVA\", \"GO\"} // (1)\n    appTypes := []string{\"API\", \"LIBRARY\"} // (2)\n\n    if len(name) &lt; 4 {\n        fmt.Println(\"ERROR: The application name must be at least 4 characters long.\")\n        os.Exit(1)\n    }\n\n    if !containsIgnoringCase(appType, appTypes) {\n        fmt.Println(fmt.Sprintf(\"ERROR: The application type must be either: %s.\", strings.Join(appTypes, \", \")))\n        os.Exit(1)\n    }\n\n    if !containsIgnoringCase(technology, technologies) {\n        fmt.Println(fmt.Sprintf(\"ERROR: The application type must be either: %s.\", strings.Join(appTypes, \", \")))\n        os.Exit(1)\n    }\n\n    return &amp;ApplicationRequest{\n        Name:       name,\n        Technology: technology,\n        Type:       appType,\n    }\n}\n</code></pre> <ol> <li>Supported technologies</li> <li>Supported application types</li> </ol> <p>Done! now we have all things complete, feel free to make refactor and more validation or changes!</p> <p>Note</p> <p>It's much easier to have validation only on the backend, but when developing the critical part, if the backend allows a new type of technology, the CLI needs to adapt as well. For our platform, this isn't a significant issue, but it's important to acknowledge that there are trade-offs.</p>"},{"location":"tutorials/using-parameters-on-cobra-cli/#calling-the-rest-api","title":"Calling the REST API","text":"<p>Be sure that the REST API is running and execute the following command:</p> <pre><code>go run cmd/platformoon/platformoon.go application create -n java -k api -t java\n</code></pre> <p>The output should look something like this:</p> <pre><code>2023/10/28 06:59:27 platformoon application create works\n2023/10/28 06:59:27 Application created: [http://localhost:8080/applications/8c2f2909-70e5-4596-8933-665a1e23b10e]\n</code></pre>"},{"location":"use-cases/","title":"Introduction","text":"<p>To begin, I'd like to outline a list of use cases for which I would like the platform to cater to my needs.</p>"},{"location":"use-cases/#us-001","title":"US-001","text":"<p>As a developer, I want to be able to create my application, download it, and then immediately start developing the business rules without having to worry about environment configurations, so that I can focus on the business itself and not on technical details and code boilerplate.</p>"},{"location":"use-cases/#how-to-address-this-use-case","title":"How to address this use case?","text":"<p>Note</p> <p>I'm not going to dwell on the various ways to solve this use case here; I'll go for the simplest one to implement, and of course, it should involve the technologies I want to learn.</p> <ul> <li>User interface: Create a GoLang CLI with Cobra.</li> <li>API: Create a Quarkus application to serve as a REST API to communicate with Github for creating a new repository.</li> </ul>"},{"location":"use-cases/#how-will-the-user-use-the-cli","title":"How will the user use the CLI?","text":"<p>To create an application, the user will type:</p> <pre><code>platformoon application create --name book-api\n</code></pre> <p>Let's address the use case US001 here.</p>"}]}