{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The goal of this repository is to document the creation of a simple Internal Developer Platform for me (Platformoon). </p> <p>This repository is a collection of documents that explain the different parts of the platform, decisions, and how I build it.</p>"},{"location":"#why","title":"Why?","text":"<p>I am a Software Engineer at MercadoLibre and I am working on the Cloud &amp; Platform TEAM creating developer toolings on top of Fury (an internal platform here), it is a great experience for me. </p> <p>With this initiative I want to build a simple an IDP skeleton to learn more about CNCF toolings and to share it with you!</p> <p>Disclaimer</p> <p>I know that it is not a real platform, but I want to learn more about this topic and I want to learn more about CNCF toolings and to share it with you.</p>"},{"location":"#platform-engineering-on-kubernetes-book","title":"Platform Engineering on Kubernetes Book","text":"<p>I am creating this repository having as a reading/reference the book Platform Engineering on Kubernetes by Mauricio Salatino. </p> <p>I contributed with some part of the code sample of the book in this repository and feel free to contribute too.</p>"},{"location":"archictecture/","title":"Introduction","text":"<p>I want that the architecture should be simple and easy to understand. I want to use the power of Kubernetes to create a simple platform that can be used by developers to deploy their applications.</p> <p>I will use a monolithic architecture to create the platform. Is simple to start and to understand too.</p>"},{"location":"archictecture/#architecture","title":"Architecture","text":"<p>The architecture will be composed of the following components:</p> <ul> <li>Kubernetes Cluster</li> <li>Platformoon API (Java/Quarkus)</li> <li>Platformoon Frontend (NextJS)</li> <li>Platformoon CLI (GoLang)</li> <li>Platformoon Documentation (mkdocs)</li> <li>Keycloak</li> </ul> <p>The main goal here is to learn and to get out from comfort zone. I hope that you can learn something too.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#allow-the-user-to-create-an-application-through-the-cli","title":"Allow the user to create an application through the CLI","text":"<p>The command should be something like this:</p> <pre><code>    platformoon create application --name=app --kind=backend\n</code></pre> <p>The result of this operation should be:</p> <ul> <li>The repository created on Github</li> <li>The application stored to be retrieved later</li> </ul>"},{"location":"features/#what-is-necessary-to-do-it","title":"What is necessary to do it?","text":"<ul> <li>Create an organization on Github</li> <li>Get the token from Github</li> <li>Create a repository on Github for the API</li> <li>Create a repository for the CLI</li> </ul> <p>Note</p> <p>For now, I will not install Keycloak and the communication between the CLI and the API will be unsafe.</p>"},{"location":"strategies/","title":"What we need first?","text":"<p>Before all, I think that we need to define what initial applications types we need to support.</p> <p>We will support only backend applications written in Go only.</p> <p>The application will be those fields:</p> <ul> <li>Name</li> <li>Description</li> <li>Repository URL (Generated by the platform)</li> <li>Technology</li> <li>Kind (backend)</li> </ul> <p>It is all, we do not need to support initially more than one backend application type. We will get the feeling configuring pipelines, deployments for one application type and then we will be able to extend the platform to support more application types.</p>"},{"location":"strategies/pipelines/","title":"Pipelines","text":"<p>To run our Platform pipelines I want to use GithubActions + Dagger. Dagger is a tool that allows us to run our pipelines locally. Dagger was born with this main goal: </p> <p>\u201cto enable developers to build pipelines using their favorite programming language that they can run everywhere\u201d.</p> <p>I like this because we can use the power of the GoLang combined with the power of Dagger to create our pipelines.</p>"},{"location":"strategies/pipelines/#what-we-need-first","title":"What we need first?","text":"<p>I think that is a good idea to create a repository to store all our pipelines. This repository will be called <code>platformoon-pipelines</code>. I will do it manually with Github.</p>"},{"location":"tutorials/","title":"Creating a Kubernetes cluster in Docker cluster with Ingress Controller","text":"<p>More details about the following steps can be found here. <pre><code>cat &lt;&lt;EOF | kind create cluster --name dev --config=-\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnodes:\n- role: control-plane\n  kubeadmConfigPatches:\n  - |\n    kind: InitConfiguration\n    nodeRegistration:\n      kubeletExtraArgs:\n        node-labels: \"ingress-ready=true\"\n  extraPortMappings:\n  - containerPort: 80\n    hostPort: 80\n    protocol: TCP\n  - containerPort: 443\n    hostPort: 443\n    protocol: TCP\n- role: worker\n- role: worker\n- role: worker\nEOF\n</code></pre></p> <p>After you need to set up the context.</p> <pre><code>kubectl cluster-info --context kind-dev\n</code></pre>"},{"location":"tutorials/#installing-the-nginx-ingress-controller","title":"Installing the NGINX Ingress Controller","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml\n</code></pre>"},{"location":"tutorials/continuous-delivery/","title":"Configuring Github Webhooks","text":"<p>In this tutorial we will configure a Github Webhook and listen all events from Github using Quarkus and <code>ngrok</code> toolings.</p>"},{"location":"tutorials/continuous-delivery/#installing-and-configuring-ngrok","title":"Installing and configuring ngrok","text":"<p>If you are not familiar with <code>ngrok</code>, see more details here.</p>"},{"location":"tutorials/continuous-delivery/#configuring-ngrok","title":"Configuring ngrok","text":"<p>Before continuing, you need to install <code>ngrok</code>, to see how to do it, follow this Getting Started tutorial.</p>"},{"location":"tutorials/continuous-delivery/#creating-a-rest-resource","title":"Creating a REST resource","text":"<p>Let's go to the our application. I created a REST resource just to log the request body from Github event.</p> <pre><code>package com.github.platformoon.presentation.resources;\n\nimport jakarta.ws.rs.Consumes;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Path(\"/gh/webhooks\")\n@Consumes(value = MediaType.APPLICATION_JSON)\n@Produces(value = MediaType.APPLICATION_JSON)\npublic class GithubWebhookResource {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(GithubWebhookResource.class);\n\n    public Response listen(String command) {\n        LOGGER.info(command);\n        return Response.ok().build();\n    }\n}\n</code></pre>"},{"location":"tutorials/continuous-delivery/#running-quarkus-application","title":"Running Quarkus application","text":"<p>Is very simple to run a Quarkus application, I am using <code>quarkus</code> CLI to do it.</p> <p>Execute the following command at the application root directory:</p> <pre><code>quarkus dev\n</code></pre> <p>The output should looks like it:</p> <pre><code>2023-10-10 09:28:37,871 INFO  [io.qua.kub.cli.dep.DevServicesKubernetesProcessor] (build-39) Dev Services for Kubernetes started. Other Quarkus applications in dev mode will find the cluster automatically.\n__  ____  __  _____   ___  __ ____  ______ \n --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/ \n -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\\ \\   \n--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/   \n2023-10-10 09:28:39,746 INFO  [io.quarkus] (Quarkus Main Thread) apps 1.0-SNAPSH2023-10-10 09:28:39,749 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.\n2023-10-10 09:28:39,750 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [agroal, cdi, hibernate-orm, jdbc-mysql, kubernetes-client, narayana-jta, rest-client, rest-client-jackson, resteasy, smallrye-context-propagation, vertx]\n</code></pre>"},{"location":"tutorials/continuous-delivery/#running-ngrok","title":"Running ngrok","text":"<p>After running the Quarkus application, will be able to execute the <code>ngrok</code>, to do it execute:</p> <pre><code>ngrok http 8080\n</code></pre> <p>The <code>http</code> say to the <code>ngrok</code> to use HTTP protocol and the 8080 indicates to proxy the request to the port 8080 (the default port used by Quarkus). The output should looks like it:</p> <pre><code>Introducing Always-On Global Server Load Balancer: https://ngrok.com/r/gslb                                                                           \n\nSession Status                online                                                                                                                  \nAccount                       email@gmail.com (Plan: Free)                                                                                  \nVersion                       3.3.5                                                                                                                   \nRegion                        South America (sa)                                                                                                      \nLatency                       13ms                                                                                                                    \nWeb Interface                 http://127.0.0.1:4040                                                                                                   \nForwarding                    https://1234-1234-7f0-90c0-6628-abcd-65c-1234-5fc6.ngrok-free.app -&gt; http://localhost:8080                              \n\nConnections                   ttl     opn     rt1     rt5     p50     p90                                                                             \n                              0       0       0.00    0.00    0.00    0.00       \n</code></pre>"},{"location":"tutorials/continuous-delivery/#configuring-the-org-webhook","title":"Configuring the org Webhook","text":"<p>Now, that we have the URL necessary to send the Webhook to our platform, let's configure it on Github.</p> <ol> <li> <p>Go to Github &gt; Settings &gt; Organizations.</p> </li> <li> <p>Select the Organization that you want, and click in Settings.</p> </li> <li> <p>Go to Webhooks.</p> </li> <li> <p>Click on <code>Add webhook</code> button.</p> </li> <li> <p>Add the Payload URL with the <code>ngrok</code> URL (in my case was necessary to add the path <code>/gh/webhooks</code> for listen it).</p> </li> <li> <p>Select <code>Let me select individual events</code>, we need just to listen tag creation and  </p> </li> <li>Click on <code>Add webhook</code> button to save.</li> </ol> <p>Done, now we can listen for all Github events and manage it.</p>"},{"location":"tutorials/pipelines/","title":"Getting Started","text":"<p>To get started with pipelines and Tekton you need a Kubernetes cluster.</p> <p>We are use KinD installed on this tutorial Installing KinD</p>"},{"location":"tutorials/pipelines/#installing-tekton","title":"Installing Tekton","text":""},{"location":"tutorials/pipelines/#why-tekton","title":"Why Tekton?","text":"<p>I wanted to learn more about Tekton and I decided to use it on this project. Tekton is a powerful and flexible open-source framework for creating CI/CD systems, allowing developers to build, test, and deploy across cloud providers and on-premise systems. It is built on Kubernetes, providing the benefits of an open-source, cloud-native experience from pipeline creation to execution.</p> <p>For more details see the official documentation.</p>"},{"location":"tutorials/pipelines/#intalling-tekton-pipelines","title":"Intalling Tekton Pipelines","text":"<pre><code>kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml\n</code></pre>"},{"location":"tutorials/pipelines/#installing-tekton-trigger","title":"Installing Tekton Trigger","text":"<pre><code>kubectl apply --filename \\\nhttps://storage.googleapis.com/tekton-releases/triggers/latest/release.yaml\nkubectl apply --filename \\\nhttps://storage.googleapis.com/tekton-releases/triggers/latest/interceptors.yaml\n</code></pre>"},{"location":"tutorials/pipelines/#installing-tekton-dashboard","title":"Installing Tekton Dashboard","text":"<pre><code>kubectl apply -f https://github.com/tektoncd/dashboard/releases/download/v0.33.0/release.yaml\n</code></pre> <p>You can access the dashboard using the following command:</p> <pre><code>kubectl port-forward svc/tekton-dashboard  -n tekton-pipelines 9097:9097\n</code></pre>"},{"location":"tutorials/pipelines/#installing-git-clone-and-buildpacks-tasks-from-tekton-hub","title":"Installing git-clone and buildpacks tasks from Tekton Hub","text":"<p>In this step we will install two tekton tasks from Tekton Hub, the git-clone and the buildpacks.</p> <p><code>git-clone</code> is a task that clones a git repository into a <code>Workspace</code> volume.</p> <p><code>buildpacks</code> is a task that builds an application using Cloud Native Buildpacks.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/tektoncd/catalog/main/task/git-clone/0.9/git-clone.yaml\nkubectl apply -f https://raw.githubusercontent.com/tektoncd/catalog/master/task/buildpacks/0.6/buildpacks.yaml\n</code></pre>"},{"location":"tutorials/pipelines/#installing-tekton-objects","title":"Installing Tekton Objects","text":"<pre><code>kubectl apply -f tekton/ci\n</code></pre>"},{"location":"tutorials/pipelines/#installing-ingress-controller-for-tekton","title":"Installing Ingress Controller for Tekton","text":"<pre><code>kubectl apply -f tekton/ingress.yaml\n</code></pre> <p>Now we have a webhook configured and we can run the pipeline using the following command:</p> <pre><code>curl --request POST \\\n  --url http://localhost/tkn/webhook \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n    \"url\": \"https://github.com/platformoon/destroyer-server.git\",\n    \"revision\": \"main\",\n    \"applicationName\": \"destroyer-server\",\n    \"action\": \"build\"\n}'\n</code></pre> <p>You can see the pipeline running at http://tekton.localhost.</p>"}]}